<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Camera Stream</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #222;
            color: white;
        }
        #video {
            width: 100%;
            max-width: 400px;
            background: black;
            border-radius: 8px;
            transform: scaleX(-1);
        }
        #status {
            margin: 20px 0;
            padding: 10px;
            background: #333;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #0078d4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #005a9e;
        }
        .controls {
            margin: 20px 0;
            padding: 15px;
            background: #333;
            border-radius: 4px;
        }
        .control-group {
            margin: 10px 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select {
            padding: 8px;
            font-size: 16px;
            border-radius: 4px;
            border: none;
            background: #444;
            color: white;
            width: 100%;
            max-width: 200px;
        }
        .flip-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .flip-button {
            flex: 1;
            padding: 10px;
            background: #555;
        }
        .flip-button.active {
            background: #0078d4;
        }
    </style>
</head>
<body>
    <h1>Mobile Camera Stream</h1>
    <video id="video" autoplay playsinline></video>
    <div id="status">Status: Disconnected</div>
    <button onclick="startStream()">Start Stream</button>
    <button onclick="stopStream()">Stop Stream</button>
    
    <div class="controls" id="controls" style="display: none;">
        <div class="control-group">
            <label for="rotation">Rotation:</label>
            <select id="rotation" onchange="updateRotation()">
                <option value="0">0°</option>
                <option value="90">90°</option>
                <option value="180">180°</option>
                <option value="270">270°</option>
            </select>
        </div>
        <div class="control-group">
            <label>Flip:</label>
            <div class="flip-buttons">
                <button id="flipH" class="flip-button" onclick="toggleFlip('H')">Flip Horizontal</button>
                <button id="flipV" class="flip-button" onclick="toggleFlip('V')">Flip Vertical</button>
            </div>
        </div>
    </div>

    <script>
        let ws;
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        let video = document.getElementById('video');
        let statusDiv = document.getElementById('status');
        
        // Rotation and flip state
        let rotation = 0;
        let flipH = false;
        let flipV = false;
        let streaming = false;
        let lastVideoWidth = 0;
        let lastVideoHeight = 0;
        let currentStream = null;
        let orientationCheckInterval = null;
        let isTransitioning = false;
        let dimensionChangeCount = 0;
        let stableDimensionCount = 0;
        const REQUIRED_STABLE_FRAMES = 3; // Wait for 3 frames with same dimensions before sending

        function checkVideoStreamHealth() {
            if (!streaming || !currentStream) return false;
            
            const videoTrack = currentStream.getVideoTracks()[0];
            if (!videoTrack) {
                console.error('No video track found');
                return false;
            }
            
            if (videoTrack.readyState !== 'live') {
                console.error(`Video track state: ${videoTrack.readyState}`);
                return false;
            }
            
            if (!video.videoWidth || !video.videoHeight) {
                console.warn('Video dimensions not available');
                return false;
            }
            
            return true;
        }

        function updateCanvasSize() {
            if (!video.videoWidth || !video.videoHeight) {
                return false;
            }
            
            if (video.videoWidth !== canvas.width || video.videoHeight !== canvas.height) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                lastVideoWidth = video.videoWidth;
                lastVideoHeight = video.videoHeight;
                console.log(`Canvas resized: ${canvas.width}x${canvas.height}`);
                return true;
            }
            return false;
        }

        async function startStream() {
            const SERVER_IP = prompt("Enter PC IP (e.g., 192.168.1.100):", "10.25.94.185");
            if (!SERVER_IP) return;

            try {
                // Get camera access with flexible constraints
                // This allows the camera to provide its natural resolution
                // which will adapt to device orientation
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'user',
                        width: { ideal: 1920, min: 640 },
                        height: { ideal: 1080, min: 480 }
                    },
                    audio: false
                });
                currentStream = stream;
                video.srcObject = stream;

                // Wait for video to load
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Video metadata load timeout'));
                    }, 5000);
                    
                    video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        resolve();
                    };
                    
                    video.onerror = (e) => {
                        clearTimeout(timeout);
                        reject(new Error('Video load error'));
                    };
                });

                // Set canvas size to match actual video dimensions
                // This adapts to device orientation automatically
                if (!updateCanvasSize()) {
                    throw new Error('Failed to get video dimensions');
                }
                
                // Listen for video resize events
                video.addEventListener('resize', () => {
                    if (streaming && checkVideoStreamHealth()) {
                        updateCanvasSize();
                    }
                });
                
                // Listen for device orientation changes with retry logic
                let orientationRetryCount = 0;
                const maxOrientationRetries = 10;
                
                const handleOrientationChange = () => {
                    isTransitioning = true;
                    dimensionChangeCount++;
                    stableDimensionCount = 0;
                    orientationRetryCount = 0;
                    console.log('Orientation change detected, pausing frame transmission...');
                    
                    const checkOrientation = () => {
                        if (!streaming || !checkVideoStreamHealth()) {
                            isTransitioning = false;
                            return;
                        }
                        
                        if (updateCanvasSize()) {
                            console.log(`Device orientation changed: ${video.videoWidth}x${video.videoHeight}`);
                            // Wait a bit for dimensions to stabilize before resuming
                            setTimeout(() => {
                                isTransitioning = false;
                                console.log('Orientation transition complete, resuming stream');
                            }, 200);
                            orientationRetryCount = 0;
                        } else if (orientationRetryCount < maxOrientationRetries) {
                            orientationRetryCount++;
                            setTimeout(checkOrientation, 100);
                        } else {
                            isTransitioning = false;
                        }
                    };
                    setTimeout(checkOrientation, 100);
                };
                
                window.addEventListener('orientationchange', handleOrientationChange);
                
                // Also listen for resize events (works on some devices)
                window.addEventListener('resize', handleOrientationChange);
                
                // Periodic health check for orientation changes
                orientationCheckInterval = setInterval(() => {
                    if (streaming && checkVideoStreamHealth()) {
                        updateCanvasSize();
                    }
                }, 500);

                // Connect to WebSocket (use wss:// for secure)
                ws = new WebSocket(`wss://${SERVER_IP}:8081`);
                
                ws.onopen = () => {
                    statusDiv.textContent = `Status: Connected to ${SERVER_IP}:8081`;
                    document.getElementById('controls').style.display = 'block';
                    streaming = true;
                    // Send initial rotation/flip settings
                    sendRotationCommand();
                    sendFlipCommand('H', flipH);
                    sendFlipCommand('V', flipV);
                    streamFrames();
                };

                ws.onerror = (error) => {
                    statusDiv.textContent = `Status: Connection Error - ${error}`;
                };

                ws.onclose = () => {
                    streaming = false;
                    statusDiv.textContent = "Status: Disconnected";
                    document.getElementById('controls').style.display = 'none';
                };

            } catch (error) {
                statusDiv.textContent = `Status: Error - ${error.message}`;
            }
        }

        function streamFrames() {
            if (!streaming || !ws || ws.readyState !== WebSocket.OPEN) {
                streaming = false;
                return;
            }

            try {
                // Check video stream health first
                if (!checkVideoStreamHealth()) {
                    console.warn('Video stream health check failed, retrying...');
                    if (streaming) {
                        setTimeout(streamFrames, 200);
                    }
                    return;
                }

                // Don't send frames during orientation transition
                if (isTransitioning) {
                    if (streaming) {
                        setTimeout(streamFrames, 50);
                    }
                    return;
                }

                // Check if dimensions are changing (orientation change in progress)
                const dimensionsChanged = (video.videoWidth !== lastVideoWidth || video.videoHeight !== lastVideoHeight);
                
                if (dimensionsChanged) {
                    dimensionChangeCount++;
                    stableDimensionCount = 0;
                    console.log(`Dimension change detected (${dimensionChangeCount}), updating canvas and waiting for stability...`);
                    // Update canvas but wait before sending frames
                    updateCanvasSize();
                    if (streaming) {
                        setTimeout(streamFrames, 50);
                    }
                    return;
                } else {
                    // Dimensions are stable, increment stable counter
                    stableDimensionCount++;
                }

                // Only send frames if dimensions have been stable for required frames
                // This prevents sending mixed-dimension frames during orientation changes
                if (stableDimensionCount < REQUIRED_STABLE_FRAMES && dimensionChangeCount > 0) {
                    if (streaming) {
                        setTimeout(streamFrames, 33);
                    }
                    return;
                }

                // Reset counters once stable
                if (stableDimensionCount >= REQUIRED_STABLE_FRAMES && dimensionChangeCount > 0) {
                    console.log(`Dimensions stabilized at ${canvas.width}x${canvas.height}, resuming normal streaming`);
                    dimensionChangeCount = 0;
                }

                // Validate canvas dimensions
                if (canvas.width === 0 || canvas.height === 0) {
                    console.warn('Invalid canvas dimensions, waiting...');
                    if (streaming) {
                        setTimeout(streamFrames, 100);
                    }
                    return;
                }

                // Draw video frame to canvas at actual dimensions
                if (video.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                    try {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    } catch (drawError) {
                        console.error('Error drawing to canvas:', drawError);
                        // Canvas might be invalid, try to recover
                        if (streaming) {
                            setTimeout(streamFrames, 100);
                        }
                        return;
                    }

                    // Convert canvas to blob and send
                    canvas.toBlob((blob) => {
                        if (!blob) {
                            console.warn('Failed to create blob from canvas');
                            if (streaming) {
                                setTimeout(streamFrames, 33);
                            }
                            return;
                        }
                        
                        if (streaming && ws && ws.readyState === WebSocket.OPEN) {
                            try {
                                ws.send(blob);
                            } catch (e) {
                                console.error('Error sending frame:', e);
                                statusDiv.textContent = `Status: Send Error - ${e.message}`;
                            }
                        }
                        // Continue streaming regardless of errors
                        if (streaming) {
                            setTimeout(streamFrames, 33);
                        }
                    }, 'image/jpeg', 0.8);
                } else {
                    // Video not ready yet, try again soon
                    if (streaming) {
                        setTimeout(streamFrames, 100);
                    }
                }
            } catch (error) {
                console.error('Error in streamFrames:', error);
                statusDiv.textContent = `Status: Streaming Error - ${error.message}`;
                // Continue streaming even after error
                if (streaming) {
                    setTimeout(streamFrames, 100);
                }
            }
        }

        function stopStream() {
            streaming = false;
            isTransitioning = false;
            dimensionChangeCount = 0;
            stableDimensionCount = 0;
            
            // Clear orientation check interval
            if (orientationCheckInterval) {
                clearInterval(orientationCheckInterval);
                orientationCheckInterval = null;
            }
            
            if (ws) {
                ws.close();
                ws = null;
            }
            
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            if (video.srcObject) {
                video.srcObject = null;
            }
            
            statusDiv.textContent = "Status: Stopped";
            document.getElementById('controls').style.display = 'none';
        }
        
        function updateRotation() {
            rotation = parseInt(document.getElementById('rotation').value);
            sendRotationCommand();
            statusDiv.textContent = `Status: Rotation set to ${rotation}°`;
        }
        
        function sendRotationCommand() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    const cmd = JSON.stringify({ action: "rotate", value: rotation });
                    ws.send(cmd);
                } catch (e) {
                    console.error('Error sending rotation command:', e);
                    statusDiv.textContent = `Status: Error sending rotation - ${e.message}`;
                }
            }
        }
        
        function toggleFlip(type) {
            if (type === 'H') {
                flipH = !flipH;
                const button = document.getElementById('flipH');
                if (flipH) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
                statusDiv.textContent = `Status: Horizontal flip ${flipH ? 'ON' : 'OFF'}`;
            } else if (type === 'V') {
                flipV = !flipV;
                const button = document.getElementById('flipV');
                if (flipV) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
                statusDiv.textContent = `Status: Vertical flip ${flipV ? 'ON' : 'OFF'}`;
            }
            sendFlipCommand(type, type === 'H' ? flipH : flipV);
        }
        
        function sendFlipCommand(type, value) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    const cmd = JSON.stringify({ action: "flip", type: type, value: value });
                    ws.send(cmd);
                } catch (e) {
                    console.error('Error sending flip command:', e);
                    statusDiv.textContent = `Status: Error sending flip - ${e.message}`;
                }
            }
        }
    </script>
</body>
</html>
